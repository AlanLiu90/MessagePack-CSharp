// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Text;
using MessagePack.Generator.CodeAnalysis;
using MessagePack.Generator.Transforms;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MessagePack.Generator;

public partial class MessagePackGenerator
{
    private static void Generate(TypeDeclarationSyntax syntax, AnalyzerOptions analyzerOptions, Compilation compilation, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken) as ITypeSymbol;
        if (typeSymbol == null)
        {
            return;
        }

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty)
            .Replace("<", "_")
            .Replace(">", "_");

        TypeCollector collector = new(compilation, true, isForceUseMap: false, ignoreTypeNames: null, typeSymbol);

        var (objectInfo, enumInfo, genericInfo, unionInfo) = collector.Collect();

        var code = GenerateFormatterSync(analyzerOptions, objectInfo, enumInfo, unionInfo, genericInfo);

        context.AddSource($"{fullType}.MessagePackFormatter.g.cs", code);
    }

    /// <summary>
    /// Generates the specialized resolver and formatters for the types that require serialization in a given compilation.
    /// </summary>
    /// <param name="options">The analyzer options.</param>
    /// <param name="objectInfo">The ObjectSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="enumInfo">The EnumSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="unionInfo">The UnionSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="genericInfo">The GenericSerializationInfo array which TypeCollector.Collect returns.</param>
    private static string GenerateFormatterSync(AnalyzerOptions options, ObjectSerializationInfo[] objectInfo, EnumSerializationInfo[] enumInfo, UnionSerializationInfo[] unionInfo, GenericSerializationInfo[] genericInfo)
    {
        var objectFormatterTemplates = objectInfo
            .GroupBy(x => (x.Namespace, x.IsStringKey))
            .Select(x =>
            {
                var (nameSpace, isStringKey) = x.Key;
                var objectSerializationInfos = x.ToArray();
                string formatterNamespace = options.FormatterNamespace + "." + nameSpace;
                var template = isStringKey ? new StringKeyFormatterTemplate(formatterNamespace, objectSerializationInfos) : (IFormatterTemplate)new FormatterTemplate(formatterNamespace, objectSerializationInfos);
                return template;
            })
            .ToArray();

        StringBuilder sb = new();

        sb.AppendLine("""
// <auto-generated />

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable CS1591 // document public APIs

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name

""");

        ResolverText(
            sb,
            options,
            genericInfo
                .Where(x => !x.IsOpenGenericType)
                .Cast<IResolverRegisterInfo>()
                .Concat(enumInfo)
                .Concat(unionInfo)
                .Concat(objectInfo.Where(x => !x.IsOpenGenericType))
                .ToArray());

        var enumFormatterTemplates = enumInfo
            .GroupBy(x => x.Namespace)
            .Select(x => new EnumTemplate($"{options.FormatterNamespace}.{x.Key}", x.ToArray()))
            .ToArray();

        var unionFormatterTemplates = unionInfo
            .GroupBy(x => x.Namespace)
            .Select(x => new UnionTemplate(options.FormatterNamespace, x.ToArray()))
            .ToArray();

        foreach (var item in enumFormatterTemplates)
        {
            var text = item.TransformText();
            sb.AppendLine(text);
        }

        sb.AppendLine();
        foreach (var item in objectFormatterTemplates)
        {
            var text = item.TransformText();
            sb.AppendLine(text);
            return sb.ToString();
        }

        sb.AppendLine();
        foreach (var item in unionFormatterTemplates)
        {
            var text = item.TransformText();
            sb.AppendLine(text);
            return sb.ToString();
        }

        return sb.ToString();
    }

    private static void ResolverText(StringBuilder sb, AnalyzerOptions options, IReadOnlyList<IResolverRegisterInfo> registerInfos)
    {
        ResolverTemplate resolverTemplate = new(options.ResolverNamespace, options.FormatterNamespace, options.ResolverName, registerInfos);
        sb.AppendLine(resolverTemplate.TransformText());
    }
}
