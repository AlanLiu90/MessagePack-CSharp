// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Text;
using MessagePack.Generator.CodeAnalysis;
using MessagePack.Generator.Transforms;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MessagePack.Generator;

public partial class MessagePackGenerator
{
    private const string FileHeader = """
// <auto-generated />

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable CS1591 // document public APIs

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name
""";

    private static void Generate(TypeDeclarationSyntax syntax, AnalyzerOptions analyzerOptions, Compilation compilation, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken) as ITypeSymbol;
        if (typeSymbol == null)
        {
            return;
        }

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty)
            .Replace("<", "_")
            .Replace(">", "_");

        TypeCollector collector = new(compilation, true, isForceUseMap: false, ignoreTypeNames: null, typeSymbol);

        var (objectInfo, enumInfo, genericInfo, unionInfo) = collector.Collect();

        Generate(context, analyzerOptions, objectInfo, enumInfo, unionInfo, genericInfo);
    }

    /// <summary>
    /// Generates the specialized resolver and formatters for the types that require serialization in a given compilation.
    /// </summary>
    /// <param name="context">Generator context.</param>
    /// <param name="options">The analyzer options.</param>
    /// <param name="objectInfos">The ObjectSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="enumInfos">The EnumSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="unionInfos">The UnionSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="genericInfos">The GenericSerializationInfo array which TypeCollector.Collect returns.</param>
    private static void Generate(IGeneratorContext context, AnalyzerOptions options, ObjectSerializationInfo[] objectInfos, EnumSerializationInfo[] enumInfos, UnionSerializationInfo[] unionInfos, GenericSerializationInfo[] genericInfos)
    {
        StringBuilder sb = new();

        ResolverTemplate resolverTemplate = new(
            options.ResolverNamespace,
            options.FormatterNamespace,
            options.ResolverName,
            genericInfos
                .Where(x => !x.IsOpenGenericType)
                .Cast<IResolverRegisterInfo>()
                .Concat(enumInfos)
                .Concat(unionInfos)
                .Concat(objectInfos.Where(x => !x.IsOpenGenericType))
                .ToArray());
        AddTransform(resolverTemplate.TransformText(), "GeneratedResolver");

        foreach (EnumSerializationInfo info in enumInfos)
        {
            EnumTemplate transform = new($"{options.FormatterNamespace}.{info.Namespace}", info);
            AddTransform(transform.TransformText(), $"{info.Namespace}.{info.Name}");
        }

        foreach (UnionSerializationInfo info in unionInfos)
        {
            UnionTemplate transform = new(options.FormatterNamespace, info);
            AddTransform(transform.TransformText(), $"Union.{info.Name}");
        }

        foreach (ObjectSerializationInfo info in objectInfos)
        {
            string formatterNamespace = $"{options.FormatterNamespace}.{info.Namespace}";
            IFormatterTemplate transform = info.IsStringKey
                ? new StringKeyFormatterTemplate(formatterNamespace, info)
                : new FormatterTemplate(formatterNamespace, info);
            AddTransform(transform.TransformText(), $"{info.Namespace}.{info.Name}");
        }

        void AddTransform(string transformOutput, string uniqueFileName)
        {
            sb.Clear();
            sb.AppendLine(FileHeader);
            sb.Append(transformOutput);
            context.AddSource($"MessagePack.{uniqueFileName}.g.cs", sb.ToString());
            sb.Clear();
        }
    }
}
