// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Text;
using MessagePack.Generator.CodeAnalysis;
using MessagePack.Generator.Transforms;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MessagePack.Generator;

public partial class MessagePackGenerator
{
    private const string FileHeader = """
// <auto-generated />

#pragma warning disable 618, 612, 414, 168, CS1591, SA1129, SA1309, SA1312, SA1403, SA1649
""";

    private static void Generate(TypeDeclarationSyntax syntax, AnalyzerOptions analyzerOptions, Compilation compilation, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken) as ITypeSymbol;
        if (typeSymbol == null)
        {
            return;
        }

        FullModel? model = TypeCollector.Collect(compilation, true, analyzerOptions, ignoreTypeNames: null, typeSymbol, context);
        if (model is not null)
        {
            Generate(context, analyzerOptions, model);
        }
    }

    /// <summary>
    /// Generates the specialized resolver and formatters for the types that require serialization in a given compilation.
    /// </summary>
    /// <param name="context">Generator context.</param>
    /// <param name="options">The analyzer options.</param>
    /// <param name="model">The full messagepack object model.</param>
    private static void Generate(IGeneratorContext context, AnalyzerOptions options, FullModel model)
    {
        StringBuilder sb = new();

        ResolverTemplate resolverTemplate = new(
            options.ResolverNamespace,
            options.FormatterNamespace,
            options.ResolverName,
            model.GenericInfos
                .Where(x => !x.IsOpenGenericType)
                .Cast<IResolverRegisterInfo>()
                .Concat(model.EnumInfos)
                .Concat(model.UnionInfos)
                .Concat(model.ObjectInfos.Where(x => !x.IsOpenGenericType))
                .ToArray());
        AddTransform(resolverTemplate.TransformText(), "GeneratedResolver");

        foreach (EnumSerializationInfo info in model.EnumInfos)
        {
            EnumTemplate transform = new($"{options.FormatterNamespace}.{info.Namespace}", info);
            AddTransform(transform.TransformText(), $"{info.Namespace}.{info.Name}");
        }

        foreach (UnionSerializationInfo info in model.UnionInfos)
        {
            UnionTemplate transform = new(options.FormatterNamespace, info);
            AddTransform(transform.TransformText(), $"Union.{info.Name}");
        }

        foreach (ObjectSerializationInfo info in model.ObjectInfos)
        {
            string formatterNamespace = $"{options.FormatterNamespace}.{info.Namespace}";
            IFormatterTemplate transform = info.IsStringKey
                ? new StringKeyFormatterTemplate(formatterNamespace, info)
                : new FormatterTemplate(formatterNamespace, info);
            AddTransform(transform.TransformText(), $"{info.Namespace}.{info.Name}");
        }

        void AddTransform(string transformOutput, string uniqueFileName)
        {
            sb.Clear();
            sb.AppendLine(FileHeader);
            sb.Append(transformOutput);
            context.AddSource($"MessagePack.{uniqueFileName}.g.cs", sb.ToString());
            sb.Clear();
        }
    }
}
