// Copyright (c) All contributors. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System.Text;
using MessagePack.Generator.CodeAnalysis;
using MessagePack.Generator.Transforms;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MessagePack.Generator;

public partial class MessagePackGenerator
{
    private const string FileHeader = """
// <auto-generated />

#pragma warning disable 618
#pragma warning disable 612
#pragma warning disable 414
#pragma warning disable 168

#pragma warning disable CS1591 // document public APIs

#pragma warning disable SA1129 // Do not use default value type constructor
#pragma warning disable SA1309 // Field names should not begin with underscore
#pragma warning disable SA1312 // Variable names should begin with lower-case letter
#pragma warning disable SA1403 // File may only contain a single namespace
#pragma warning disable SA1649 // File name should match first type name
""";

    private static void Generate(TypeDeclarationSyntax syntax, AnalyzerOptions analyzerOptions, Compilation compilation, IGeneratorContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken) as ITypeSymbol;
        if (typeSymbol == null)
        {
            return;
        }

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", string.Empty)
            .Replace("<", "_")
            .Replace(">", "_");

        TypeCollector collector = new(compilation, true, isForceUseMap: false, ignoreTypeNames: null, typeSymbol);

        var (objectInfo, enumInfo, genericInfo, unionInfo) = collector.Collect();

        Generate(context, analyzerOptions, objectInfo, enumInfo, unionInfo, genericInfo);
    }

    /// <summary>
    /// Generates the specialized resolver and formatters for the types that require serialization in a given compilation.
    /// </summary>
    /// <param name="context">Generator context.</param>
    /// <param name="options">The analyzer options.</param>
    /// <param name="objectInfo">The ObjectSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="enumInfo">The EnumSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="unionInfo">The UnionSerializationInfo array which TypeCollector.Collect returns.</param>
    /// <param name="genericInfo">The GenericSerializationInfo array which TypeCollector.Collect returns.</param>
    private static void Generate(IGeneratorContext context, AnalyzerOptions options, ObjectSerializationInfo[] objectInfo, EnumSerializationInfo[] enumInfo, UnionSerializationInfo[] unionInfo, GenericSerializationInfo[] genericInfo)
    {
        StringBuilder sb = new();

        ResolverTemplate resolverTemplate = new(
            options.ResolverNamespace,
            options.FormatterNamespace,
            options.ResolverName,
            genericInfo
                .Where(x => !x.IsOpenGenericType)
                .Cast<IResolverRegisterInfo>()
                .Concat(enumInfo)
                .Concat(unionInfo)
                .Concat(objectInfo.Where(x => !x.IsOpenGenericType))
                .ToArray());
        AddTransform(resolverTemplate.TransformText(), "GeneratedResolver");

        foreach (EnumSerializationInfo enumI in enumInfo)
        {
            EnumTemplate transform = new($"{options.FormatterNamespace}.{enumI.Namespace}", new[] { enumI });
            AddTransform(transform.TransformText(), $"{enumI.Namespace}.{enumI.Name}");
        }

        foreach (UnionSerializationInfo union in unionInfo)
        {
            UnionTemplate transform = new(options.FormatterNamespace, new[] { union });
            AddTransform(transform.TransformText(), $"Union.{union.Name}");
        }

        foreach (ObjectSerializationInfo info in objectInfo)
        {
            string formatterNamespace = $"{options.FormatterNamespace}.{info.Namespace}";
            IFormatterTemplate transform = info.IsStringKey
                ? new StringKeyFormatterTemplate(formatterNamespace, new[] { info })
                : new FormatterTemplate(formatterNamespace, new[] { info });
            AddTransform(transform.TransformText(), $"{info.Namespace}.{info.Name}");
        }

        void AddTransform(string transformOutput, string uniqueFileName)
        {
            sb.Clear();
            sb.AppendLine(FileHeader);
            sb.Append(transformOutput);
            context.AddSource($"MessagePack.{uniqueFileName}.g.cs", sb.ToString());
            sb.Clear();
        }
    }
}
